#include <iostream>
#include <string>
#include <unordered_map>
#include <fstream>

// Token管理與攻擊次數追蹤
class TokenManager {
private:
    std::unordered_map<std::string, bool> validTokens;
    int attackCount = 0;
    const int attackThreshold = 3; // 攻擊次數閾值
    const std::string logFile = "attack_log.txt";

    void logAttack(const std::string& detail) {
        std::ofstream logStream(logFile, std::ios::app);
        if (logStream.is_open()) {
            logStream << detail << std::endl;
            logStream.close();
        }
    }

public:
    void addToken(const std::string& token) {
        validTokens[token] = true;
    }

    bool validateToken(const std::string& token) {
        if (validTokens.find(token) != validTokens.end() && validTokens[token]) {
            return true;
        } else {
            attackCount++;
            logAttack("攻擊偵測: 使用 token " + token + " | 攻擊次數: " + std::to_string(attackCount));
            return false;
        }
    }

    bool isBlocked() {
        return attackCount >= attackThreshold;
    }
};

// 反覆輸入並檢查長度在8到16字元的金鑰函式
std::string inputValidatedKey(const std::string& prompt) {
    std::string key;
    while (true) {
        std::cout << prompt;
        std::getline(std::cin, key);
        if (key.length() < 8) {
            std::cerr << "金鑰太短，請輸入至少8個字元。\n";
        } else if (key.length() > 16) {
            std::cerr << "金鑰太長，請輸入不超過16個字元。\n";
        } else {
            break; // 長度合理，跳出迴圈
        }
    }
    return key;
}

// API請求模擬
struct ApiRequest {
    std::string token;
    std::string payload;
};

bool defendAgainstSpoofing(const ApiRequest& request, TokenManager& manager) {
    if (manager.isBlocked()) {
        std::cerr << "服務已因多次攻擊暫停。\n";
        return false;
    }
    if (!manager.validateToken(request.token)) {
        std::cerr << "偵測到API偽造攻擊：Token無效或缺失。\n";
        if (manager.isBlocked()) {
            std::cerr << "由於多次攻擊，服務已被鎖定。\n";
        }
        return false;
    }
    std::cout << "API請求驗證通過，處理資料 \"" << request.payload << "\"。\n";
    return true;
}

int main() {
    TokenManager tokenManager;

    // 互動模式設定金鑰
    std::string key1 = inputValidatedKey("請輸入設定的金鑰 (8-16字元): ");
    std::string key2 = inputValidatedKey("請再次輸入金鑰以驗證: ");
    if (key1 != key2) {
        std::cerr << "兩次輸入的金鑰不一致，程式終止。\n";
        return 1;
    }
    tokenManager.addToken(key1);
    std::cout << "金鑰設定成功！\n" << std::endl;

    // 互動驗證流程，使用者可多次輸入Token測試
    while (true) {
        std::string inputToken;
        std::cout << "請輸入API Token以驗證（輸入'exit'結束程式）: ";
        std::getline(std::cin, inputToken);
        if (inputToken == "exit") break;

        ApiRequest req{inputToken, "範例資料"};
        if (!defendAgainstSpoofing(req, tokenManager)) {
            if (tokenManager.isBlocked()) {
                std::cerr << "服務因攻擊次數達上限而被鎖定。\n";
                break;
            }
        }
    }

    std::cout << "結束API演示。\n";
    return 0;
}
