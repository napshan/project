#include <iostream>
#include <fstream>
#include <string>
#include <ctime>
#include <chrono>
#include <iomanip>
#include <sstream>
#include <map>
#include <vector>
/*#include <openssl/hmac.h>
#include <openssl/evp.h>
#include <nlohmann/json.hpp>*/

using json = nlohmann::json;
using namespace std;

// ------------------- 設定 -------------------
const std::string FALLBACK_SECRET = "default_fallback_secret";

// ------------------- Base64URL 編碼/解碼 -------------------
std::string base64UrlEncode(const std::string& input) {
    BIO* b64 = BIO_new(BIO_f_base64());
    BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);
    BIO* mem = BIO_new(BIO_s_mem());
    b64 = BIO_push(b64, mem);
    BIO_write(b64, input.data(), input.size());
    BIO_flush(b64);

    BUF_MEM* bufferPtr;
    BIO_get_mem_ptr(b64, &bufferPtr);

    std::string encoded(bufferPtr->data, bufferPtr->length);
    BIO_free_all(b64);

    // Base64URL 替換
    for (auto& c : encoded) {
        if (c == '+') c = '-';
        else if (c == '/') c = '_';
    }
    encoded.erase(remove(encoded.begin(), encoded.end(), '='), encoded.end());
    return encoded;
}

std::string base64UrlDecode(const std::string& input) {
    std::string b64 = input;
    for (auto& c : b64) {
        if (c == '-') c = '+';
        else if (c == '_') c = '/';
    }
    while (b64.size() % 4) b64 += '=';
    BIO* b64bio = BIO_new(BIO_f_base64());
    BIO_set_flags(b64bio, BIO_FLAGS_BASE64_NO_NL);
    BIO* mem = BIO_new_mem_buf(b64.data(), b64.size());
    mem = BIO_push(b64bio, mem);
    std::vector<char> buffer(b64.size());
    int len = BIO_read(mem, buffer.data(), buffer.size());
    BIO_free_all(mem);
    return std::string(buffer.data(), len);
}

// ------------------- HMAC-SHA256 -------------------
std::string hmacSha256(const std::string& data, const std::string& key) {
    unsigned char result[EVP_MAX_MD_SIZE];
    unsigned int len = 0;
    HMAC(EVP_sha256(), key.data(), key.size(),
         (unsigned char*)data.data(), data.size(), result, &len);
    return std::string((char*)result, len);
}

// ------------------- JWT 生成 -------------------
std::string generateJwt(const std::string& headerJson, const std::string& payloadJson, const std::string& secret) {
    std::string header = base64UrlEncode(headerJson);
    std::string payload = base64UrlEncode(payloadJson);
    std::string data = header + "." + payload;
    std::string signature = hmacSha256(data, secret);
    return data + "." + base64UrlEncode(signature);
}

// ------------------- 日誌紀錄 -------------------
void log_event(const std::string& event, const std::string& account, const std::string& detail) {
    std::ofstream file("events.log", std::ios::app);
    auto now = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
    std::stringstream ss;
    ss << std::put_time(std::localtime(&now), "%Y-%m-%dT%H:%M:%S");
    file << "{\"timestamp\":\"" << ss.str()
         << "\",\"event\":\"" << event
         << "\",\"account\":\"" << account
         << "\",\"detail\":\"" << detail << "\"}" << std::endl;
}

// ------------------- 驗證 JWT -------------------
bool validateJwt(const std::string& token, const std::string& secret, std::string& userId, bool& expired, std::string& detail) {
    size_t p1 = token.find('.');
    size_t p2 = token.find('.', p1 + 1);
    if (p1 == std::string::npos || p2 == std::string::npos) {
        detail = "malformed token";
        return false;
    }

    std::string header_b64 = token.substr(0, p1);
    std::string payload_b64 = token.substr(p1 + 1, p2 - p1 - 1);
    std::string sig_b64 = token.substr(p2 + 1);

    std::string data = header_b64 + "." + payload_b64;
    std::string expected_sig = hmacSha256(data, secret);
    std::string expected_b64 = base64UrlEncode(expected_sig);

    if (expected_b64 != sig_b64) {
        detail = "signature mismatch";
        return false;
    }

    std::string payload = base64UrlDecode(payload_b64);
    json payloadJson;
    try {
        payloadJson = json::parse(payload);
    } catch (...) {
        detail = "invalid JSON payload";
        return false;
    }

    if (!payloadJson.contains("userId")) {
        detail = "no userId field";
        return false;
    }
    userId = payloadJson["userId"];

    if (payloadJson.contains("exp")) {
        uint64_t exp = payloadJson["exp"];
        uint64_t now = (uint64_t)std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
        if (exp < now) {
            expired = true;
            detail = "token expired";
            return false;
        }
    }

    return true;
}

// ------------------- 權限檢查 -------------------
bool checkPermission(const std::string& userId, const std::string& requiredRole) {
    static std::map<std::string, std::string> roles = {
        {"user1", "admin"},
        {"user2", "viewer"}
    };

    if (!roles.count(userId)) {
        log_event("anomaly_user_not_found", userId, "no such account");
        return false;
    }

    std::string role = roles[userId];
    if (role != requiredRole) {
        log_event("anomaly_insufficient_permission", userId, "need role=" + requiredRole + ", have=" + role);
        return false;
    }
    return true;
}

// ------------------- 主程式 -------------------
int main(int argc, char* argv[]) {
    const char* env = std::getenv("SECRET_KEY");
    std::string secret = (env && std::string(env).size() > 0) ? env : FALLBACK_SECRET;

    std::string scenario = "success";
    if (argc > 1) scenario = argv[1];

    std::string userId = "user1";
    std::string requiredRole = "admin";
    uint64_t now = (uint64_t)std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());

    std::string payloadJson;
    if (scenario == "success")
        payloadJson = "{\"userId\":\"user1\",\"exp\":" + std::to_string(now + 3600) + "}";
    else if (scenario == "invalid_sig")
        payloadJson = "{\"userId\":\"user1\",\"exp\":" + std::to_string(now + 3600) + "}";
    else if (scenario == "expired")
        payloadJson = "{\"userId\":\"user1\",\"exp\":" + std::to_string(now - 60) + "}";
    else if (scenario == "insufficient_role") {
        payloadJson = "{\"userId\":\"user1\",\"exp\":" + std::to_string(now + 3600) + "}";
        requiredRole = "superadmin";
    } else if (scenario == "user_not_found")
        payloadJson = "{\"userId\":\"nosuchuser\",\"exp\":" + std::to_string(now + 3600) + "}";
    else if (scenario == "malformed")
        payloadJson = "{\"userId\":\"user1\"}";
    else if (scenario == "tampered")
        payloadJson = "{\"userId\":\"user1\",\"exp\":" + std::to_string(now + 3600) + "}";
    else {
        std::cout << "Unknown scenario: " << scenario << std::endl;
        return 1;
    }

    std::string headerJson = "{\"alg\":\"HS256\",\"typ\":\"JWT\"}";
    std::string jwt = generateJwt(headerJson, payloadJson, secret);

    std::string validateSecret = secret;
    if (scenario == "invalid_sig")
        validateSecret = "different_secret_to_force_invalid_signature";
    else if (scenario == "malformed")
        jwt = "this_is_not.a.validtoken";
    else if (scenario == "tampered") {
        size_t p1 = jwt.find('.');
        size_t p2 = jwt.find('.', p1 + 1);
        std::string header_b64 = jwt.substr(0, p1);
        std::string sig_b64 = jwt.substr(p2 + 1);
        std::string tampered = "{\"userId\":\"attacker\",\"exp\":" + std::to_string(now + 3600) + "}";
        std::string tampered_b64 = base64UrlEncode(tampered);
        jwt = header_b64 + "." + tampered_b64 + "." + sig_b64;
    }

    std::cout << "\n=== Scenario: " << scenario << " ===\n";
    std::cout << "JWT: " << jwt << "\n";

    std::string parsedUser;
    bool expired = false;
    std::string detail;
    bool ok = validateJwt(jwt, validateSecret, parsedUser, expired, detail);

    std::string logUser = parsedUser.empty() ? (scenario=="user_not_found" ? "nosuchuser" : "unknown") : parsedUser;

    if (!ok) {
        if (expired) {
            log_event("anomaly_expired_token", logUser, detail);
            std::cout << "[!] Token expired\n";
        } else {
            log_event("anomaly_invalid_jwt_signature", logUser, detail);
            std::cout << "[!] Invalid token: " << detail << "\n";
        }
        return 1;
    }

    if (!checkPermission(logUser, requiredRole)) {
        std::cout << "[!] Permission denied\n";
        return 1;
    }

    std::cout << "[+] Access granted for " << logUser << " (role ok)\n";
    log_event("api_access_granted", logUser, "scenario=" + scenario);
    return 0;
}
